## Array와 List
- List는 컬렉션을 상속받고 있으며 List를 상속받는 모든 컬렉션 클래스는 값의 순서가 유지되고 중복을 허용한다.
- Array는 크기를 초기화 시켜놓고 사용해야 해서 데이터의 크기를 가늠하기 어려울 경우 크기를 지정하지 않고 동적으로 값을 관리하는 List를 많이 사용한다.

## 요약
- Array는 인덱스로 빠르게 값을 찾는 것이 가능
- LinkedList는 데이터의 삽입 및 삭제가 빠르지만 조회가 느림
- ArrayList는 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느림

## ArrayList 
- ArrayList는 내부적으로 데이터를 배열에서 관리하며 임시 배열을 생성에 데이터를 복사하여 데이터의 추가,삭제를 수행한다.
  - 배열을 이용하기 때문에 크기를 변경할 수 없어 임시 배열 생성
- 각 데이터는 인덱스를 가지고 있기 때문에 한번에 참조가 가능해 데이터의 검색에는 유리하나 대량의 자료를 변경할 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하를 일으킬 수 있다.

## LinkdeList
- LinkedList는 내부적으로 Linked list를 사용하여 값을 저장한다.
- 저장된 요소는 비순차적으로 분포되며 이러한 요소들을 링크로 연결하여 구성한다.(데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있음)
- 데이터 추가,삭제 시 불필요한 데이터의 복사가 필요없어 ArrayList가 배열을 이용했을 때 생기는 단점을 보완할 수 있다.
- 그러나 데이터를 조회하기 위해서는 처음부터 노드를 순회해야 하기 때문에 성능상 불리하다.

## 데이터의 검색/삽입/삭제 성능 비교
#### 검색
- ArrayList : 인덱스 기반의 자료 구조로 get(index)를 통해 O(1)의 시간복잡도를 가진다.
- LinkedList : 모든 요소를 탐색해야한느 구조로 최악의 경우 O(N)의 시간복잡도를 가진다.

#### 삽입/삭제
- ArrayList : 삽입/삭제 이후 다른 데이터를 복사해야하기 때문에 최악의 경우 O(N)의 시간복잡도를 가진다.
- LinkedList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 O(1)의 시간복잡도를 가진다.
